//
// Created by Иван on 10/21/2024.
//


#include "NetGeometry.h"

Node::Node(int index, double xCoord, double yCoord, double zCoord)
        : ind(index), x(xCoord), y(yCoord), z(zCoord) {}

Element::Element(const int index, const std::vector<int> &nIndexes, int size)
        : ind(index), nodeIndexes(nIndexes), dim(size), edgeIndexes(), centroid2D() {
}

Edge::Edge(int index, int node1, int node2, int neighbor1, int neighbor2, double len, const std::vector<double>& normalVec, const std::vector<double>& midP)
        : ind(index), nodeInd1(node1), nodeInd2(node2),
          neighbourInd1(neighbor1), neighbourInd2(neighbor2), length(len), normalVector(normalVec), midPoint(midP) {}


double areaCalc(const Element& poly, const NodePool& nPool) {
    int dim = poly.dim;
    std::vector<Node> polyNodes;
    for(int i = 0; i < dim; ++i){
        polyNodes.push_back(nPool.nodes[poly.nodeIndexes[i]]);
    }
    double res = 0.0;
    double iSum = 0.0;
    double jSum = 0.0;
    double kSum = 0.0;
    for(int k = 1; k < dim-1; ++k){
        double yk_y1 = polyNodes[k].y - polyNodes[0].y;  //y_k - y_1
        double zk1_z1 = polyNodes[k+1].z - polyNodes[0].z; // z_{k+1} - z_1
        double zk_z1 = polyNodes[k].z - polyNodes[0].z;
        double yk1_y1 = polyNodes[k+1].y - polyNodes[0].y;
        double xk1_x1 = polyNodes[k+1].x - polyNodes[0].x;
        double xk_x1 = polyNodes[k].x - polyNodes[0].x;
        iSum += (yk_y1 * zk1_z1 - zk_z1 * yk1_y1);
        jSum += (zk_z1 * xk1_x1 - xk_x1 * zk1_z1);
        kSum += (xk_x1 * yk1_y1 - yk_y1 * xk1_x1);
    }
    res = 0.5 * std::sqrt(iSum*iSum + jSum*jSum + kSum*kSum);
    return res;
}

std::vector<double> getElementCentroid2D(const Element &poly, const NodePool &nPool) {
    int dim = poly.dim;
    std::vector<double> centroid(2, 0.0);
    for(int i = 0; i < dim; ++i){
        Node node = nPool.getNode(poly.nodeIndexes[i]);
        centroid[0] += node.x;
        centroid[1] += node.y;
    }
    centroid[0] /= dim;
    centroid[1] /= dim;
    return centroid;
}

std::vector<double> getMidPoint2D(const int nodeInd1, const int nodeInd2, const NodePool &nPool) {
    Node node1 = nPool.getNode(nodeInd1);
    Node node2 = nPool.getNode(nodeInd2);
    std::vector<double> mid{(node1.x + node2.x)/2.0, (node1.y + node2.y)/2.0};
    return mid;
}

double getDistance(const int nodeInd1, const int nodeInd2, const NodePool& nPool){
    Node node1 = nPool.getNode(nodeInd1);
    Node node2 = nPool.getNode(nodeInd2);
    return std::sqrt( (node1.x - node2.x)*(node1.x - node2.x) + (node1.y - node2.y)*(node1.y - node2.y) + (node1.z - node2.z)*(node1.z - node2.z) );
}


NodePool::NodePool(int size, const std::vector<Node>& nodeVec)
        : nodeCount(size), nodes(nodeVec) {}

Node NodePool::getNode(int ind) const{
    return nodes[ind];
}

EdgePool::EdgePool(int size, const std::vector<Edge>& edgeVec)
        : edgeCount(size), edges(edgeVec) {
    minEdgeLen = edgeVec[0].length;
    for (const auto& edge : edgeVec) {
        if(edge.length < minEdgeLen && edge.length > 1e-16){
            minEdgeLen = edge.length;
        }
    }
}


// Function to calculate the 2D normal vector between two nodes
std::vector<double> calculateNormalVector2D(const Node& node1, const Node& node2) {
    // Calculate the direction vector from node1 to node2
    double dx = node2.x - node1.x;
    double dy = node2.y - node1.y;

    // Calculate the normal vector (perpendicular to the direction vector)
    // Counterclockwise 90-degree rotation
    std::vector<double> normal = {-dy, dx};

    // Optionally, normalize the normal vector
    double length = std::sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
    if (length > 0) {
        normal[0] /= length;
        normal[1] /= length;
    }
    return normal;
}

////ЖЁТСКИЙ КОСТЫЛЬ, УБЕРУ ПОТОМ , КОГДА БУДЕТ МЕСТО НА BOOST
    namespace std {
    template <typename T1, typename T2>
    struct hash<std::pair<T1, T2>> {
        size_t operator()(const std::pair<T1, T2>& p) const {
            auto h1 = std::hash<T1>{}(p.first);
            auto h2 = std::hash<T2>{}(p.second);
            return h1 ^ (h2 << 1); // Combine the two hash values
        }
    };
}
EdgePool::EdgePool(const NodePool& np, ElementPool& ep) {
    //<key type, calue type, hash function>
    // is a hash function specifically designed for hashing std::pair<int, int> objects. The hash value generated by this function is used to distribute the pairs across the hash table.
    //!!!!!!!!!TODO:убрать бред с кастомом и добавить boost:hash
    std::unordered_map<std::pair<int, int>, std::unordered_set<int>, std::hash<std::pair<int, int>>> edgeMap;
    int edgeIndex = 0;
    minEdgeLen = 10000000.0;
    // Loop through each element to create edges
    for (const auto& element : ep.elements) {
        int dim = element.dim;
        if(dim != 3){
            std::cout << "dim != 3" << std::endl;
        }
        for (int i = 0; i < dim; ++i) {
            int node1 = element.nodeIndexes[i];
            int node2 = element.nodeIndexes[(i + 1) % dim]; // Ensure cyclical connectivity
            if (node1 > node2) std::swap(node1, node2); // Ensure consistent ordering
            auto edgeKey = std::make_pair(node1, node2);
            edgeMap[edgeKey].insert(element.ind); // Insert element index into the unordered_set for this edge
        }
    }

    // Now iterate through the edgeMap to create edges
    for (const auto& edgeEntry : edgeMap) {
        int node1 = edgeEntry.first.first;
        int node2 = edgeEntry.first.second;
        const auto& neighbors = edgeEntry.second; // Get the set of neighboring elements
        int neighbor1 = -1, neighbor2 = -1;
        auto it = neighbors.begin();
        if (it != neighbors.end()) {
            neighbor1 = *it;
            ++it;
            if (it != neighbors.end()) {
                neighbor2 = *it;
            }
        }
        int orientation = 1;
        if(neighbor1 == -1){
            std::swap(neighbor1,neighbor2);
        }
        std::vector<double> normalVector = calculateNormalVector2D(np.getNode(node1), np.getNode(node2));
        std::vector<double> edgeMid = getMidPoint2D(node1, node2, np);
        //std::cout << "CENTROID OF THE EL numb " << neighbor1 << " , centroid = (" << getElementCentroid2D(ep.elements[neighbor1], np)[0] << ", " <<getElementCentroid2D(ep.elements[neighbor1], np)[1]  <<") " << std::endl;
        std::vector<double> neighbour1ToEdgeMidVector =
                    edgeMid - ep.elements[neighbor1].centroid2D;
        orientation = normalVector * neighbour1ToEdgeMidVector > 0 ? 1 : -1;
        if(orientation < 0){
            normalVector = normalVector * (-1);
            orientation = 1;
        }

        const auto &elementNodes = ep.elements[neighbor1].nodeIndexes;
        auto itNode1 = std::find(elementNodes.begin(), elementNodes.end(), node1);
        auto itNode2 = std::find(elementNodes.begin(), elementNodes.end(), node2);

        if ((itNode1 > itNode2) && !(itNode1 == elementNodes.end()-1 && itNode2 == elementNodes.begin()) ) {
            std::swap(node1, node2); // Swap nodes to ensure counterclockwise order
            //std::cout << "swap1 EdgeIndex is " << edgeIndex << std::endl;
        }
        else if(itNode2 == elementNodes.end()-1 && itNode1 == elementNodes.begin()){
            std::swap(node1, node2);
            //std::cout << "swap2 EdgeIndex is " << edgeIndex << std::endl;
        }

        double len = getDistance(node1, node2, np);
        if(len < minEdgeLen && len > 1e-16){
            minEdgeLen = len;
        }
        // Create the edge and add it to the list
        edges.emplace_back(edgeIndex, node1, node2, neighbor1, neighbor2, len, normalVector, edgeMid);

        ++edgeIndex;
    }

    edgeCount = edges.size();  // Set the total number of edges
}

ElementPool::ElementPool(int nodesPerElement, int elCnt, const std::vector<Element>& elems)
        : elCount(elCnt), isSquare(nodesPerElement == SQUARE_ELEMENT_NODE_COUNT),
          isTriangular(nodesPerElement == TRIANGULAR_ELEMENT_NODE_COUNT), elements(elems) {
}

void World::setNodePool(const NodePool& np) {
    this->np = np;
}

NodePool World::getNodePool() const {
    return np;
}

void World::setElementPool(const ElementPool& ep) {
    this->ep = ep;
}

ElementPool World::getElementPool() const {
    return ep;
}

/*NEIGHBOUR SERVICE*/
NeighbourService::NeighbourService(const NodePool& np, const ElementPool& ep, const EdgePool& edgePool) {
    // Reserve space for maps
    nodeToElements.reserve(np.nodeCount);
    edgeToElements.reserve(edgePool.edgeCount);
    elementToElements.reserve(ep.elCount);
    nodeToEdgesMap.reserve(np.nodeCount);

    // Parallelize node-to-elements and edge-to-elements population
#pragma omp parallel for
    for (size_t i = 0; i < ep.elements.size(); ++i) {
        const auto& element = ep.elements[i];

        // Use OpenMP critical section for thread-safe map updates
        for (int nodeIndex : element.nodeIndexes) {
#pragma omp critical(nodeToElements)
            {
                nodeToElements[nodeIndex].insert(element.ind);
            }
        }

    }

    // Parallelize node-to-edges map population
#pragma omp parallel for
    for (size_t edgeIndex = 0; edgeIndex < edgePool.edges.size(); ++edgeIndex) {
        const auto& edge = edgePool.edges[edgeIndex];

#pragma omp critical(nodeToEdgesMap)
        {
            nodeToEdgesMap[edge.nodeInd1].push_back(edgeIndex);
            nodeToEdgesMap[edge.nodeInd2].push_back(edgeIndex);
        }
    }
}

int NeighbourService::findEdgeByNodes(int node1Index, int node2Index, const EdgePool& edgePool) const {
    for (int i = 0; i < edgePool.edges.size(); ++i) {
        const auto& edge = edgePool.edges[i];
        if ((edge.nodeInd1 == node1Index && edge.nodeInd2 == node2Index) ||
            (edge.nodeInd1 == node2Index && edge.nodeInd2 == node1Index)) {
            return i; // Return the index of the matching edge
        }
    }
    return -1; // Return -1 if no edge is found
}

std::vector<int> NeighbourService::getEdgeNeighborsOfNode(int nodeIndex) const {
    auto it = nodeToEdgesMap.find(nodeIndex);
    if (it != nodeToEdgesMap.end()) {
        return it->second; // Return the list of edge indexes
    }
    return {}; // Return an empty vector if the node is not found
}

std::unordered_set<int> NeighbourService::getNodeNeighbours(int nodeIndex) const {
    return nodeToElements.at(nodeIndex);
}

std::unordered_set<int> NeighbourService::getEdgeNeighbours(int edgeIndex) const {
    return edgeToElements.at(edgeIndex);
}

std::unordered_set<int> NeighbourService::getElementNeighbours(int elementIndex) const {
    return elementToElements.at(elementIndex);
}

// Method to get edges of an element
std::unordered_set<int> NeighbourService::getEdgesOfElement(int elementIndex) const {
    return elementToEdges.at(elementIndex);
}

// Method to get elements of an edge
std::unordered_set<int> NeighbourService::getElementsOfEdge(int edgeIndex) const {
    return edgeToElementsMap.at(edgeIndex);
}


// Displaying neighbors and the relationships between nodes, elements, and edges
void NeighbourService::displayNeighbours() const {
    std::cout << "\n--- Neighbours ---" << std::endl;

    // Node to Element Neighbours
    std::cout << "\nNode to Element Neighbours:" << std::endl;
    for (const auto& [node, elements] : nodeToElements) {
        std::cout << "Node " << node << ": ";
        for (int elem : elements) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    // Element to Element Neighbours
    std::cout << "\nElement to Element Neighbours:" << std::endl;
    for (const auto& [element, neighbours] : elementToElements) {
        std::cout << "Element " << element << ": ";
        for (int neigh : neighbours) {
            std::cout << neigh << " ";
        }
        std::cout << std::endl;
    }

    // Edge to Element Neighbours
    std::cout << "\nEdge to Element Neighbours:" << std::endl;
    for (const auto& [edge, elements] : edgeToElements) {
        std::cout << "Edge " << edge << ": ";
        for (int elem : elements) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    // Node to Edges
    for(const auto& [node, edges]: nodeToEdgesMap) {
        std::cout << "Node " << node << " is connected to edges: ";
        for(const auto& edge: edges) {
            std::cout << edge << " ";
        }
        std::cout << std::endl;
    }
}


/*WORLD*/
NeighbourService& World::getNeighbourService() {
    return ns;
}

World::World(const std::string &fileName, const bool isRenderedBin) : np(), ep(), edgp(), ns(np, ep, edgp) {

    // Готовый пререндеренный мир (всё посчитано и записано в bin-файле)
    if(isRenderedBin) {
        importFromFile(fileName);
    }
    else {
        std::ifstream file(fileName);
        assert(file.is_open());

        std::vector<Node> nodes;
        std::vector<Element> elements;
        std::string tmp_line;

        while (std::getline(file, tmp_line)) {
            if (tmp_line == "$Nodes") {
                std::getline(file, tmp_line);  // Size
                std::getline(file, tmp_line);  // First enter
                while (tmp_line != "$EndNodes") {
                    int ind;
                    double x, y, z;
                    std::istringstream ss(tmp_line);
                    ss >> ind >> x >> y >> z;  // Read all values in one go
                    nodes.emplace_back(ind - 1, x, y, z);
                    std::getline(file, tmp_line);
                }
            } else if (tmp_line == "$Elements") {
                std::getline(file, tmp_line); // Size
                std::getline(file, tmp_line); // First enter
                while (tmp_line != "$EndElements") {
                    int ind, count;
                    std::istringstream ss(tmp_line);
                    ss >> ind >> count; // Read index and count

                    std::vector<int> indexes(count);
                    for (int i = 0; i < count; ++i) {
                        ss >> indexes[i]; // Directly read into vector
                        indexes[i] -= 1;
                    }
                    elements.emplace_back(ind-1, indexes, count);
                    std::getline(file, tmp_line);
                }
            }
        }

        std::cout << "Creating node and element pools..." << std::endl;
        np = NodePool(nodes.size(), nodes);
        ep = ElementPool(nodes[0].ind, elements.size(), elements); // Assuming nodes[0].ind is the nodesPerElement

        for (int i = 0; i < ep.elCount; ++i) {
            ep.elements[i].area = areaCalc(ep.elements[i], np);
            ep.elements[i].centroid2D = getElementCentroid2D(ep.elements[i], np);
        }

        std::cout << "Creating edgepool..." << std::endl;
        edgp = EdgePool(np, ep);  // Construct edges based on NodePool and ElementPool
        std::cout << "Creating neighbour service..." << std::endl;
        ns = NeighbourService(np, ep, edgp);

        for (auto &element: ep.elements) {
            for (int i = 0; i < element.dim; ++i) {
                int nodeInd = element.nodeIndexes[i];
                int nodeInd_after = element.nodeIndexes[(i + 1) % element.dim];
                int edgeInd = ns.findEdgeByNodes(nodeInd, nodeInd_after, edgp);
                if (edgeInd > -1) {
                    element.edgeIndexes.push_back(edgeInd);
                }
            }
        }
#pragma omp parallel for
        for (size_t i = 0; i < ep.elements.size(); ++i) {
            const auto &element = ep.elements[i];
            for (int edgeIndex: element.edgeIndexes) {
#pragma omp critical(edgeToElements)
                {
                    ns.edgeToElements[edgeIndex].insert(element.ind);
                }
            }
        }

        // Parallelize element-to-element connections
#pragma omp parallel for
        for (size_t i = 0; i < ep.elements.size(); ++i) {
            const auto& element = ep.elements[i];
            std::unordered_set<int> connectedElements;

            for (int edgeIndex : element.edgeIndexes) {
                connectedElements.insert(ns.edgeToElements[edgeIndex].begin(),ns.edgeToElements[edgeIndex].end());

            }
            connectedElements.erase(connectedElements.find(element.ind));
            // Update the map in a thread-safe manner
#pragma omp critical(elementToElements)
            {
                ns.elementToElements[element.ind] = std::move(connectedElements);
            }
        }
    }
}

void World::display() const {
    // Display Node Pool
    std::cout << "Node Pool:" << std::endl;
    std::cout << "Total Nodes: " << np.nodeCount << std::endl;
    for (const auto& node : np.nodes) {
        std::cout << "Node Index: " << node.ind << ", Coordinates: ("
                  << node.x << ", " << node.y << ", " << node.z << ")" << std::endl;
    }

    // Display Element Pool
    std::cout << "\nElement Pool:" << std::endl;
    std::cout << "Total Elements: " << ep.elCount << std::endl;
    for (const auto& element : ep.elements) {
        std::cout << "Element Index: " << element.ind << ", Node Count: " << element.dim
                  << ", Node Indices: ";
        for (const auto& index : element.nodeIndexes) {
            std::cout << index << " ";
        }
        std::cout << ", Area: " << element.area << ", Edges: (";
        for(const auto& index: element.edgeIndexes){
            std::cout << index << " ";
        }
        std::cout << ")"<<std::endl;
    }

    // Display Edge Pool and Edge Neighbors
    std::cout << "\nEdge Pool:" << std::endl;
    std::cout << "Total Edges: " << edgp.edgeCount << std::endl;
    for (const auto& edge : edgp.edges) {
        std::cout << "Edge Index: " << edge.ind << ", Nodes: ("
                  << edge.nodeInd1 << ", " << edge.nodeInd2 << "), "
                  << "Neighbors: (" << edge.neighbourInd1 << ", " << edge.neighbourInd2 << ")"
                  << ", Normal: ("
                  << edge.normalVector[0] << ", " << edge.normalVector[1] << "), len = "
                  << edge.length << ", MidPoint = ("<< edge.midPoint[0] << ", "<< edge.midPoint[1] << ")"<<std::endl;
    }

    // Display Neighbor Information for Nodes, Edges, and Elements
    ns.displayNeighbours();
}

EdgePool World::getEdgePool() const {
    return edgp;
}

void World::setEdgePool(const EdgePool &edgp) {
    this->edgp = edgp;
}

void World::exportToFile(const string &filename) const{
    std::ofstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + filename);
    }

    // Write NodePool
    int nodeCount = np.nodeCount;
    file.write(reinterpret_cast<const char*>(&nodeCount), sizeof(nodeCount));
    for (const auto& node : np.nodes) {
        file.write(reinterpret_cast<const char*>(&node.ind), sizeof(node.ind));
        file.write(reinterpret_cast<const char*>(&node.x), sizeof(node.x));
        file.write(reinterpret_cast<const char*>(&node.y), sizeof(node.y));
        file.write(reinterpret_cast<const char*>(&node.z), sizeof(node.z));
    }

    // Write ElementPool
    int elementCount = ep.elCount;
    file.write(reinterpret_cast<const char*>(&elementCount), sizeof(elementCount));
    for (const auto& element : ep.elements) {
        file.write(reinterpret_cast<const char*>(&element.ind), sizeof(element.ind));
        int dim = element.dim;
        file.write(reinterpret_cast<const char*>(&dim), sizeof(dim));
        for (const auto& nodeIndex : element.nodeIndexes) {
            file.write(reinterpret_cast<const char*>(&nodeIndex), sizeof(nodeIndex));
        }
        if(element.dim != element.edgeIndexes.size()){
            std::cout << element.dim << " vs " << element.edgeIndexes.size() << std::endl;
            std::cout << element.ind << " element has area = " << element.area << std::endl;
            std::cout << "Elem's nodes are: ";
            for(const auto& ind: element.nodeIndexes){
                Node curnode = np.getNode(ind);
                std::cout << ind << "( "<< curnode.x << ", " << curnode.y << ", " << curnode.z << " ); ";
            }

            std::cout << std::endl;
        }
        for(const auto& edgeIndex: element.edgeIndexes){
            file.write(reinterpret_cast<const char*>(&edgeIndex), sizeof(edgeIndex));
        }
        double area = element.area;
        file.write(reinterpret_cast<const char*>(&area), sizeof(area));
        for (const auto& coord : element.centroid2D) {
            file.write(reinterpret_cast<const char*>(&coord), sizeof(coord));
        }
    }

    // Write EdgePool
    int edgeCount = edgp.edgeCount;
    file.write(reinterpret_cast<const char*>(&edgeCount), sizeof(edgeCount));
    for (const auto& edge : edgp.edges) {
        file.write(reinterpret_cast<const char*>(&edge.ind), sizeof(edge.ind));
        file.write(reinterpret_cast<const char*>(&edge.nodeInd1), sizeof(edge.nodeInd1));
        file.write(reinterpret_cast<const char*>(&edge.nodeInd2), sizeof(edge.nodeInd2));
        file.write(reinterpret_cast<const char*>(&edge.neighbourInd1), sizeof(edge.neighbourInd1));
        file.write(reinterpret_cast<const char*>(&edge.neighbourInd2), sizeof(edge.neighbourInd2));
        file.write(reinterpret_cast<const char*>(&edge.length), sizeof(edge.length));
        for (const auto& val : edge.normalVector) {
            file.write(reinterpret_cast<const char*>(&val), sizeof(val));
        }
        for (const auto& val : edge.midPoint) {
            file.write(reinterpret_cast<const char*>(&val), sizeof(val));
        }
    }

    // Serialize NeighbourService
    // Export node-to-elements map
    int nodeToElementsSize = ns.nodeToElements.size();
    file.write(reinterpret_cast<const char*>(&nodeToElementsSize), sizeof(nodeToElementsSize));
    for (const auto& [node, elements] : ns.nodeToElements) {
        file.write(reinterpret_cast<const char*>(&node), sizeof(node));
        int elementCount = elements.size();
        file.write(reinterpret_cast<const char*>(&elementCount), sizeof(elementCount));
        for (int elem : elements) {
            file.write(reinterpret_cast<const char*>(&elem), sizeof(elem));
        }
    }

    // Export element-to-elements map
    int elementToElementsSize = ns.elementToElements.size();
    file.write(reinterpret_cast<const char*>(&elementToElementsSize), sizeof(elementToElementsSize));
    for (const auto& [element, neighbors] : ns.elementToElements) {
        file.write(reinterpret_cast<const char*>(&element), sizeof(element));
        int neighborCount = neighbors.size();
        file.write(reinterpret_cast<const char*>(&neighborCount), sizeof(neighborCount));
        for (int neighbor : neighbors) {
            file.write(reinterpret_cast<const char*>(&neighbor), sizeof(neighbor));
        }
    }

    // Export edge-to-elements map
    int edgeToElementsSize = ns.edgeToElements.size();
    file.write(reinterpret_cast<const char*>(&edgeToElementsSize), sizeof(edgeToElementsSize));
    for (const auto& [edge, elements] : ns.edgeToElements) {
        file.write(reinterpret_cast<const char*>(&edge), sizeof(edge));
        int elementCount = elements.size();
        file.write(reinterpret_cast<const char*>(&elementCount), sizeof(elementCount));
        for (int elem : elements) {
            file.write(reinterpret_cast<const char*>(&elem), sizeof(elem));
        }
    }

    // Export node-to-edges map
    int nodeToEdgesMapSize = ns.nodeToEdgesMap.size();
    file.write(reinterpret_cast<const char*>(&nodeToEdgesMapSize), sizeof(nodeToEdgesMapSize));
    for (const auto& [node, edges] : ns.nodeToEdgesMap) {
        file.write(reinterpret_cast<const char*>(&node), sizeof(node));
        int edgeCount = edges.size();
        file.write(reinterpret_cast<const char*>(&edgeCount), sizeof(edgeCount));
        for (int edge : edges) {
            file.write(reinterpret_cast<const char*>(&edge), sizeof(edge));
        }
    }


    file.close();
    std::cout << "World exported to " << filename << std::endl;
}

void World::importFromFile(const string &filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + filename);
    }

    // Read NodePool
    int nodeCount;
    file.read(reinterpret_cast<char*>(&nodeCount), sizeof(nodeCount));
    std::vector<Node> nodes(nodeCount);
    for (auto& node : nodes) {
        file.read(reinterpret_cast<char*>(&node.ind), sizeof(node.ind));
        file.read(reinterpret_cast<char*>(&node.x), sizeof(node.x));
        file.read(reinterpret_cast<char*>(&node.y), sizeof(node.y));
        file.read(reinterpret_cast<char*>(&node.z), sizeof(node.z));
    }
    np = NodePool(nodeCount, nodes);

    // Read ElementPool
    int elementCount;
    file.read(reinterpret_cast<char*>(&elementCount), sizeof(elementCount));
    std::vector<Element> elements(elementCount);
    for (auto& element : elements) {
        file.read(reinterpret_cast<char*>(&element.ind), sizeof(element.ind));
        int dim;
        file.read(reinterpret_cast<char*>(&dim), sizeof(dim));
        element.dim = dim;
        element.nodeIndexes.resize(dim);
        for (auto& nodeIndex : element.nodeIndexes) {
            file.read(reinterpret_cast<char*>(&nodeIndex), sizeof(nodeIndex));
        }
        element.edgeIndexes.resize(dim);
        for (auto& edgeIndex : element.edgeIndexes) {
            file.read(reinterpret_cast<char*>(&edgeIndex), sizeof(edgeIndex));
        }
        file.read(reinterpret_cast<char*>(&element.area), sizeof(element.area));
        element.centroid2D.resize(2);
        for (auto& coord : element.centroid2D) {
            file.read(reinterpret_cast<char*>(&coord), sizeof(coord));
        }
    }
    ep = ElementPool(elements[0].dim, elementCount, elements);

    // Read EdgePool
    int edgeCount;
    file.read(reinterpret_cast<char*>(&edgeCount), sizeof(edgeCount));
    std::vector<Edge> edges(edgeCount);
    for (auto& edge : edges) {
        file.read(reinterpret_cast<char*>(&edge.ind), sizeof(edge.ind));
        file.read(reinterpret_cast<char*>(&edge.nodeInd1), sizeof(edge.nodeInd1));
        file.read(reinterpret_cast<char*>(&edge.nodeInd2), sizeof(edge.nodeInd2));
        file.read(reinterpret_cast<char*>(&edge.neighbourInd1), sizeof(edge.neighbourInd1));
        file.read(reinterpret_cast<char*>(&edge.neighbourInd2), sizeof(edge.neighbourInd2));
        file.read(reinterpret_cast<char*>(&edge.length), sizeof(edge.length));
        edge.normalVector.resize(2);
        for (auto& val : edge.normalVector) {
            file.read(reinterpret_cast<char*>(&val), sizeof(val));
        }
        edge.midPoint.resize(2);
        for (auto& val : edge.midPoint) {
            file.read(reinterpret_cast<char*>(&val), sizeof(val));
        }
    }
    edgp = EdgePool(edgeCount, edges);

    // Deserialize NeighbourService
    // Import node-to-elements map
    int nodeToElementsSize;
    file.read(reinterpret_cast<char*>(&nodeToElementsSize), sizeof(nodeToElementsSize));
    ns.nodeToElements.clear();
    for (int i = 0; i < nodeToElementsSize; ++i) {
        int node;
        file.read(reinterpret_cast<char*>(&node), sizeof(node));
        int elementCount;
        file.read(reinterpret_cast<char*>(&elementCount), sizeof(elementCount));
        std::unordered_set<int> elements;
        for (int j = 0; j < elementCount; ++j) {
            int elem;
            file.read(reinterpret_cast<char*>(&elem), sizeof(elem));
            elements.insert(elem);
        }
        ns.nodeToElements[node] = elements;
    }

    // Import element-to-elements map
    int elementToElementsSize;
    file.read(reinterpret_cast<char*>(&elementToElementsSize), sizeof(elementToElementsSize));
    ns.elementToElements.clear();
    for (int i = 0; i < elementToElementsSize; ++i) {
        int element;
        file.read(reinterpret_cast<char*>(&element), sizeof(element));
        int neighborCount;
        file.read(reinterpret_cast<char*>(&neighborCount), sizeof(neighborCount));
        std::unordered_set<int> neighbors;
        for (int j = 0; j < neighborCount; ++j) {
            int neighbor;
            file.read(reinterpret_cast<char*>(&neighbor), sizeof(neighbor));
            neighbors.insert(neighbor);
        }
        ns.elementToElements[element] = neighbors;
    }

    // Import edge-to-elements map
    int edgeToElementsSize;
    file.read(reinterpret_cast<char*>(&edgeToElementsSize), sizeof(edgeToElementsSize));
    ns.edgeToElements.clear();
    for (int i = 0; i < edgeToElementsSize; ++i) {
        int edge;
        file.read(reinterpret_cast<char*>(&edge), sizeof(edge));
        int elementCount;
        file.read(reinterpret_cast<char*>(&elementCount), sizeof(elementCount));
        std::unordered_set<int> elements;
        for (int j = 0; j < elementCount; ++j) {
            int elem;
            file.read(reinterpret_cast<char*>(&elem), sizeof(elem));
            elements.insert(elem);
        }
        ns.edgeToElements[edge] = elements;
    }

    // Import node-to-edges map
    int nodeToEdgesMapSize;
    file.read(reinterpret_cast<char*>(&nodeToEdgesMapSize), sizeof(nodeToEdgesMapSize));
    ns.nodeToEdgesMap.clear();
    for (int i = 0; i < nodeToEdgesMapSize; ++i) {
        int node;
        file.read(reinterpret_cast<char*>(&node), sizeof(node));
        int edgeCount;
        file.read(reinterpret_cast<char*>(&edgeCount), sizeof(edgeCount));
        std::vector<int> edges(edgeCount);
        for (int j = 0; j < edgeCount; ++j) {
            file.read(reinterpret_cast<char*>(&edges[j]), sizeof(edges[j]));
        }
        ns.nodeToEdgesMap[node] = edges;
    }

    file.close();
    std::cout << "World imported from " << filename << std::endl;
}

void setNeighbourEdge(Element& el, const int edgeInd){
    el.nodeIndexes.push_back(edgeInd);
}
